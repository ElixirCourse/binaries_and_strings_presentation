#HSLIDE
## Низове и binaries
![Image-Absolute](assets/basics.jpg)

#HSLIDE
## За какво ще си говорим днес?

1. Как да да работим с двоичните структури - binaries
2. Как са представени двоичните структури
3. Низове
4. Някои уловки при низовете

#HSLIDE
## Binaries

#HSLIDE
### Конструкция
```elixir
<<>>

<< 123, 23, 1 >>

<< 0b01111011, 0b00010111, 0b00000001 >> == << 123, 23, 1 >>
true

iex> << 280 >>
<<24>>
```

#HSLIDE
```elixir
iex> << 280::size(16) >> # Същото като << 280::16 >>
<< 1, 24 >>

iex> << 0b00000001, 0b00011000 >> == << 280::16 >>
true

<< 128::7 >>
1 # 10000001 - 1/0000001
```

#HSLIDE
* Интересно е съхранението на числа с плаваща запетая като `binaries`.
* Винаги се представят като `binary` от 8 байта:

```elixir
iex> << 5.5::float >>
<<64, 22, 0, 0, 0, 0, 0, 0>>
```

#HSLIDE
### Конкатенация

#HSLIDE
```elixir
iex> << 83, 79, 83 >> <> << 24, 4 >>
<<83, 79, 83, 24, 4>>

<< 83, 79, 83, << 24, 4 >> >>
```

#HSLIDE
### Размер

```elixir
iex> byte_size(<< 83, 79, 83 >>)
3

byte_size(<< 34::5, 23::2, 12::2 >>)
2

# Между другото:
<< 34::5, 23::2, 12::2 >> == << 22, 0::1 >>
true

```elixir
iex> bit_size(<< 34::5, 23::2, 12::2 >>)
9
```

#HSLIDE
### Проверки

Има два метода за проверяване на типа на променлива, свързани с `binary` структурите.
1. `is_bitstring` - Винаги е истина за каквато и да е валидна поредица от данни между `<<` и `>>`. Няма значение дължината върната от `bit_size`.
2. `is_binary` - Истина е само ако `bit_size` връща число кратно на `8` - тоест структурата е поредица от байтове.

#HSLIDE
### Sub-binaries

#HSLIDE
С функцията `binary_part`, можем да боравим с части от дадена `binary` структура:

```elixir
iex> binary_part(<< 83, 79, 83, 23, 21, 12 >>, 1, 3)
<<79, 83, 23>>
```

#HSLIDE
## Pattern matching

Като всичко друго в Elixir и с `binaries` можем да съпоставяме:

```elixir
<< x, y, x >> = << 83, 79, 83 >>

x
83

y
79
```

#HSLIDE
```elixir
iex> << x, y, z::binary >> = << 83, 79, 83, 43, 156 >>
<<83, 79, 83, 43, 156>>
iex> z
<< 83, 43, 156 >>

# Ако не го направим така, автоматично сапоставя променлива на 1 байт:
iex> << x, y, z >> = << 83, 79, 83, 43, 156 >>
** (MatchError) no match of right hand side value: <<83, 79, 83, 43, 156>>
```

#HSLIDE
```elixir
iex> << sign::size(1), exponent::size(11), mantissa::size(52) >> = << 4815.162342::float >>
<<64, 178, 207, 41, 143, 62, 204, 196>>
iex> sign
0
```

```elixir
iex> :math.pow(-1, sign) * (1 + mantissa / :math.pow(2, 52)) * :math.pow(2, exponent - 1023)
4815.162342
```

#HSLIDE
Модификатори:
* `float`
* `binary` или `bytes`
* `integer` модификатор, който се прилага по подразбиране
* `bits` или `bitstrig`
* `utf8`
* `utf16`
* `utf32`

#HSLIDE
```elixir
iex> << x::5, y::bits >> = << 225 >>
<<225>>
iex> x
28
iex> y
<<1::size(3)>>
```

#HSLIDE
* Интересно нещо свързано с модификаторите е, че `size` работи с тях.
* Да речем `size` задава дължина в битове, когато работим с `integer`.
* Aко работим с `binary` модификатор, `size` е в байтове.

#HSLIDE
```elixir
iex> << x::binary-size(4), _::binary >> = << 83, 222, 0, 345, 143, 87 >>
<<83, 222, 0, 89, 143, 87>>
iex> x # 4 байта
<<83, 222, 0, 89>>
```

#HSLIDE
## Binaries - имплементация

#HSLIDE
* По принцип всеки процес в `Elixir` има собствен `heap`.
* За всеки процес различни структури от данни и стойности са съхранени в този `heap`. <!-- .element: class="fragment" -->
* Когато два процеса си комуникират, съобщенията, които се изпращат между тях се копират между `heap`-овете им. <!-- .element: class="fragment" -->

#HSLIDE
### Heap Binary
* Ако `binary`-то е `64` **байта** или по-малко, то е съхранявано в `heap`-a на процеса си.
* Такива `binary` структурки наричаме **heap binaries**.

#HSLIDE
### Refc Binary
* Когато структурката ни е по-голяма от `64` **байта**, тя не се пази в `process heap`-a.
* Пази се в обща памет за всички process-и на даден `node`.
* В `porcess heap`-a се пази малко обектче, наречено **ProcBin**, което е указател към даденото `binary`.
* `binary` структурка може да бъде сочена от множество такива `ProcBin` указатели от множество процеси.

#HSLIDE
* Пази се _reference counter_ за всеки от тези указатели.
* Когато той стане `0`, Garbage Collector-ът ще може да изчисти `binary`-то от общия `heap`.
* Такива `binary` структури наричаме **refc binaries**.

#HSLIDE
### Sub binaries
* Указател към съществуващо `binary` пазещ по-малка от неговата дължина.
* Няма копиране.
* Броячът на референции се увеличава.
* Функцията `binary_part` да речем създава такива.

#HSLIDE
### Matching context
* Подобен на `sub binary`, но оптимизиран за `binary pattern matching`.
* Държи указател към двоичните данни в паметта.
* Когато нещо е `match`-нато, указателят се придвижва напред.
* Компилаторът избягва създаването на `sub binary` за всяка `match`-ната променлива.
* Ако е възможно и преизползва един и същ `match context`.

#HSLIDE
```elixir
x = << 83, 222, 0, 89 >>
y = << x, 225, 21 >>
z = << y, 125, 156 >>
a = << y, 15, 16, 19 >>
```

#HSLIDE
## Низове

#HSLIDE
### Низове
Низовете в `Elixir` се дефинират с двойни кавички и са с _UTF-8_ encoding:

#HSLIDE
```elixir
iex> "Здрасти"
"Здрасти"
iex> "Здрасти #{:Pesho}" # Интерполация
"Здрасти Pesho"
iex> "Един
...> стринг
...> на
...> повече
...> от един ред"
"Един\nстринг\nна\nповече\nот един ред"
```

#HSLIDE
```elixir
iex> is_binary("Здрасти")
true
iex> String.length("Здрасти") # Брой на символи
7
iex> byte_size("Здрасти") # Брой на байтове
14
iex> "Бял" <> " мерцедес!" # Конкатенация
"Бял мерцедес!"
```

#HSLIDE
### Списъци
* Има специален модул, `List`, за работа с тях.
* Не държат стойностите си подредени в паметта.
* Намирането на дължината им, четене на стойност по index, добавяне на стойност на index и триене на стойност на index са все линейни операции.

#HSLIDE
```elixir
iex> [1, 2, "три", 4.0] # Не са хомогенни
[1, 2, "три", 4.0]
iex> length [1, 2, 3, 5, 8] # Дължината
5
iex> hd [1, 2, 3, 5, 8]
1
iex> tl [1, 2, 3, 5, 8]
[2, 3, 5, 8]
iex> is_list([1, 2])
true
iex> 'Еликсир' # Списък от unicode codepoint-и
[1045, 1083, 1080, 1082, 1089, 1080, 1088]
iex> [83, 79, 83]
'SOS'
```

#HSLIDE
### Кортежи
![Image-Absolute](assets/tuple.jpg)

#HSLIDE
### Кортежи
* Кортежите съхраняват елементите си подредени един след друг в паметта.
* Достъпът до елемент по индекс и взимането на дължината им са константни операции.

#HSLIDE
### Кортежи
* Заедно с атомите за връщане на множество стойности от функция.
* За `pattern matching` - ще видим малко по-долу.
* Read-only колекция, защото писането в тях е скъпа операция.

#HSLIDE
```elixir
iex> {:ok, 7}
{:ok, 7}
iex> tuple_size({:ok, 7, 5})
3
iex> is_tuple({:ok, 7, 5})
true
```

#HSLIDE
### Keyword lists
Списъци, които съдържат `tuple`-и от по два елемента - атом и каквато и да е стойност.

#HSLIDE
```elixir
iex>[{:one, 1}, {:two, 2}]
[one: 1, two: 2]
iex> [one: 1, two: 2]
[one: 1, two: 2]
```

#HSLIDE
* Ако keyword list е последен аргумент на функция, можем да пропуснем квадратните скоби при извикване:
```elixir
iex> f(1, 2, three: 3, four: 4)
```

#HSLIDE
* Ключовете им могат да се повтарят.
* Използват се и за предаване на command line параметри или опции на функции.
* Пример е `String.split/3`.
```elixir
iex> String.split("one,two,,,three,,,four", ",", trim: true)
["one", "two", "three", "four"]
```

#HSLIDE
### Maps
* Колекции от ключове и стойности.
* `Map`-овете в `Elixir` не позволяват еднакви ключове.
* За ключове може да се използва всичко и дори няма нужда да бъдат един и същи тип,
но обикновено се използват низове или атоми.

#HSLIDE
### Бинарен тип (Binaries)
Прдставляват поредици от битове и байтове.
```elixir
iex> << 2 >> # Цялото число 2 в 1 байт
<<2>>
iex> byte_size << 2 >>
1
iex> << 255 >> # Цялото число 255 в 1 байт
<<255>>
iex> << 256 >> # Превърта и става 0
<<0>>
iex> <<1, 2>> # Две цели числа в два байта.
<<1, 2>>
iex> byte_size << 1, 2 >>
2
```

#HSLIDE
```elixir
iex> << 5::size(3), 1::size(1), 5::size(4) >>
<<181>>
iex> 0b10110101
181
iex> byte_size << 5::size(3), 1::size(1), 5::size(4) >>
1
iex> is_bitstring << 5::size(3), 1::size(1) >>
true
iex> is_binary << 5::size(3), 1::size(1) >>
false
```

#HSLIDE
* Интересен факт - низовете в `Elixir` са имплементирани като `binary` тип.
* Спомняте си че `is_binary("Стринг")` връщаше `true`.
```elixir
iex> <<208, 170, 208, 156>> = "ЪМ"
"ЪМ"
```

#HSLIDE
### Анонимни функции
```elixir
iex> fn (x) -> x + 1 end
#Function<6.52032458/1 in :erl_eval.expr/5>
iex> (fn (x) -> x + 1 end).(4) # Извикване
5
iex> is_function((fn (x) -> x + 1 end))
true
```

#HSLIDE
```elixir
iex> &(&1 + 1)
#Function<6.52032458/1 in :erl_eval.expr/5>
iex> (&(&1 + 1)).(4)
5
```

#HSLIDE
### Други типове
* Други типове са `Port`, `Reference` и `PID`, които се използват с процеси.
* Има и регулярни изрази. `~r/\w+/im`
* Ranges : `(1..1000)`
* Има различни shortcut-синтаксиси за дефиниране на някои от типовете.

#HSLIDE
## Съпоставяне на образци
![Image-Absolute](assets/patterns.jpg)

#HSLIDE
## Съпоставяне на образци
* В Elixir `pattern matching`-a е еднa от най-важните и основни особености.
* Операторът `=` се нарича `match operator`.
* Можем да го сравним с знака `=` в математиката.

#HSLIDE
## Съпоставяне на образци
* Използвайки го, превръщаме целия израз в уравнение, в което сравняваме лявата с дясната страна.
* Ако сравнението е успешно се връща стойността на това уравнение, ако не - има грешка.

#HSLIDE
```elixir
iex> x = 5
5
iex> 5 = x
5
iex> 4 = x
** (MatchError) no match of right hand side value: 1

```

#HSLIDE
#### Засега за `match operator`-а знаем:
1. С него могат да се дефинират променливи.
2. С него могат да се правят проверки - дали дадена променлива има дадена стойност.

#HSLIDE
* Имената на променливи задължително започват с малка латинска буква или подчертавка (`_`),
следвана от букви, цифри или подчертавки.
* Могат да завършват на `?` или `!`.
* Операторът `=` ще опита да присвои на всички възможни променливи от ляво стойности от дясно.

#HSLIDE
```elixir
iex> {one, tWo, t3, f_our, five!} = {1, 2, 3, 4, 5}
{1, 2, 3, 4, 5}
iex> one
1
iex> tWo
2
iex> t3
3
iex> f_our
4
iex> five!
5
```

#HSLIDE
```elixir
iex(107)> [head|tail] = [1, 2, 4, 5]
[1, 2, 4, 5]
iex> head
1
iex> tail
[2, 4, 5]
iex> [a, b|tail] = [1, 2, 4, 5]
[1, 2, 4, 5]
iex> a
1
iex> b
2
iex> tail
[4, 5]
```

#HSLIDE
```elixir
iex> g = fn
...>   0 -> 0
...>   x -> x - 1
...> end
#Function<6.52032458/1 in :erl_eval.expr/5>
iex> g.(0)
0
iex> g.(3)
2
```

#HSLIDE
![Image-Absolute](assets/pins.jpg)

#HSLIDE
* В `Elixir` e възможно да променим стойността на променлива.
* В `Erlang` това не е възможно.

#HSLIDE
Ако искаме една променлива, която вече съществува да не промени стойността си при съпоставяне,
можем да използваме `pin` оператора - `^`.
```elixir
iex> x = 5
5
iex> ^x = 6
** (MatchError) no match of right hand side value: 6
```

#HSLIDE
```elixir
iex> {y, ^x} = {5, 4}
```

#HSLIDE
Ако се опитаме да присвоим стойност на `unbound` променлива (досега не е съществувала),
използвайки `pin` оператора, ще получим грешка.
```elixir
iex> ^z = 4
** (CompileError) iex:56: unbound variable ^z
```

#HSLIDE
## Неизменимост
![Image-Absolute](assets/immutable.png)

#HSLIDE
## Неизменимост
* Ще си говорим за immutability, pattern matching и рекурсия на всяка лекция.
* Или поне ще ги споменаваме. <!-- .element: class="fragment" -->
* Както и за процесите! <!-- .element: class="fragment" -->

#HSLIDE
```elixir
iex> base_list = [1, 2, 3]
[1, 2, 3]
iex> new_list = [0 | base_list]
[0, 1, 2, 3]
```

#HSLIDE
## Това беше за днес.
![Image-Absolute](assets/end.jpg)
